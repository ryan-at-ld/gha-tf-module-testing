name: Tag New Modules Versions
run-name: Tagging
on:
  pull_request:
    branches:
      - main
    types:
      - opened
      - closed
      - reopened
      - synchronize
jobs:
  modified-version-files:
    runs-on: ubuntu-latest
    name: Find modified VERSION files
    outputs:
      matrix: ${{ steps.changed-version-files.outputs.all_changed_files }}
    steps:
      - uses: actions/checkout@v4
      - name: Get changed version files
        id: changed-version-files
        uses: tj-actions/changed-files@4edd678ac3f81e2dc578756871e4d00c19191daf #v45
        with:
          matrix: true
          files: |
            resources/*/VERSION
            services/*/VERSION
  
  tag-modules:
    name: Create Git tag for modules with new versions
    runs-on: ubuntu-latest
    needs: [ modified-version-files ]
    permissions:
      contents: write
      pull-requests: write
    strategy:
      matrix:
        file: ${{ fromJSON(needs.modified-version-files.outputs.matrix) }}
      max-parallel: 2
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Parse the version file
        id: parse-version-file
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('node:fs');

            try {

              const filename = '${{ matrix.file }}';
              core.info(`Processing file "${filename}".`);
            
              const components = filename.split('/');
              const moduleType = components[0];
              const moduleName = components.slice(1,-1).join('/').toLowerCase();
              const moduleDirectory = [moduleType, moduleName].join('/');
            
              core.info(`Parsing version file for ${moduleType} module "${moduleName}"`);

              const version = fs.readFileSync(filename, 'utf8').trim();
              // TODO: Check for empty string and invalid characters
              const tag = `${moduleName}/${version}`.toLowerCase();
              core.info(`The "${tag}" tag will be used for the new version of the module.`);

              core.setOutput('module-directory', moduleDirectory);
              core.setOutput('module-name', moduleName);
              core.setOutput('module-type', moduleType);
              core.setOutput('tag', tag);
              core.setOutput('version', version);
            
            } catch (err) {
               core.setFailed(`Action failed with error ${err}`);
            }
      # TODO: Check for existing tag
      - name: Create release
        id: create-release
        uses: actions/github-script@v7
        if: github.event.pull_request.merged == true
        with:
          script: |
            const sourceUrl = `git::ssh://git@github.com/${{ github.repository }}//${{ steps.parse-version-file.outputs.module-directory }}?ref=${{ steps.parse-version-file.outputs.tag }}`
            const name = '${{ steps.parse-version-file.outputs.module-name }} ${{ steps.parse-version-file.outputs.version }}'
            const body = `
            Version ${{ steps.parse-version-file.outputs.version }} of ${{ steps.parse-version-file.outputs.module-type }} module [${{ steps.parse-version-file.outputs.module-name }}](${{ steps.parse-version-file.outputs.module-directory }}). 
            
            To use this version of the module, set the \`source\` argument of the module call to the following value.
            \`${sourceUrl}\`.
            
            This release was generated for pull request #${{ github.event.number }}.
            `
            github.rest.repos.createRelease({
              body: body,
              name: name,
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: '${{ steps.parse-version-file.outputs.tag }}',
              target_commitish: '${{ github.sha }}'
            });
            
